<!DOCTYPE html>
<html lang="en">
<head>
    <script>
       // SECURITY CHECK & FIREBASE VERIFICATION
        const storedName = localStorage.getItem('playerName');
        
        // Basic Local Check
        if (localStorage.getItem('isLoggedIn') !== 'true' || !storedName) {
            window.location.href = '../LoginPlease/login.html';
        } else {
            // Extra Protection: Check if user actually exists in Firebase
            const checkId = storedName.toLowerCase().trim();
            db.ref('users/' + checkId).once('value', snap => {
                if (!snap.exists()) {
                    // Agar database mein user nahi mila (Banned ya Fake User)
                    alert("Your access deined! Please re-login for access!");
                    localStorage.removeItem('isLoggedIn');
                    localStorage.removeItem('playerName');
                    window.location.href = './LoginPlease/login.html';
                }
            });
        }
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>City Drift Online</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@500;700&display=swap');
        
        * { touch-action: none; -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Teko', sans-serif; color: #333; user-select: none; }
        
        #game-container { position: fixed; inset: 0; z-index: 1; }

        /* --- SIDEBARS --- */
        #code-sidebar {
            position: absolute; top: 80px; right: -250px; width: 220px;
            background: rgba(0,0,0,0.9); border: 2px solid #2ecc71;
            padding: 15px; border-radius: 10px 0 0 10px; transition: 0.5s;
            pointer-events: auto; z-index: 1200; color: white;
        }
        #code-sidebar.open { right: 0; }
        .side-btn { 
            position: absolute; left: -40px; top: 0; width: 40px; height: 50px;
            background: #2ecc71; color: white; display: flex; align-items: center;
            justify-content: center; cursor: pointer; border-radius: 5px 0 0 5px; font-size: 1.5rem;
        }

        .invite-toggle-btn {
            position: absolute; top: 15px; right: 15px; background: transparent;
            border: none; color: #2ecc71; font-size: 2.2rem; cursor: pointer;
            z-index: 1500; text-shadow: 0 0 5px white; pointer-events: auto;
        }
        .sidebar-menu {
            position: fixed; top: 0; right: 0; width: 280px; height: 100%;
            background: rgba(10, 10, 10, 0.95); border-left: 2px solid #2ecc71;
            transform: translateX(100%); transition: transform 0.4s ease;
            z-index: 1600; display: flex; flex-direction: column; padding: 20px;
            pointer-events: auto;
        }
        .sidebar-menu.active { transform: translateX(0); }
        .sidebar-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 15px; }
        .close-btn { background: transparent; border: none; color: #ff0055; font-size: 2.2rem; cursor: pointer; }
        #invite-list { overflow-y: auto; flex-grow: 1; }

        /* --- CHAT (Moved to top-left to avoid pedals) --- */
        #chat-sidebar {
            position: absolute; top: 15px; left: 15px; width: 250px;
            height: 120px; background: rgba(255,255,255,0.2); border-radius: 8px;
            display: flex; flex-direction: column; pointer-events: auto; z-index: 1100;
            border: 1px solid rgba(0,0,0,0.1); backdrop-filter: blur(10px);
        }
        #chat-messages { flex: 1; overflow-y: auto; padding: 5px; font-size: 0.9rem; font-family: sans-serif; color: #000; }
        #chat-input { background: rgba(255,255,255,0.5); border: none; padding: 5px 10px; color: #000; font-family: 'Teko'; font-size: 1.1rem; outline: none; }

        /* --- UI OVERLAY --- */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; display: none; z-index: 1050; }
        .controls-container { position: absolute; bottom: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; align-items: flex-end; pointer-events: auto; }
        .btn-touch { width: 70px; height: 70px; background: rgba(255,255,255,0.3); border: 2px solid #fff; border-radius: 50%; color: #333; display: flex; align-items: center; justify-content: center; font-size: 1.8rem; backdrop-filter: blur(5px); }
        .pedal { width: 65px; height: 100px; border-radius: 12px; font-size: 1.1rem; font-weight: bold; }
        .gas { background: rgba(46, 204, 113, 0.4); border-color: #2ecc71; }
        .brake { background: rgba(231, 76, 60, 0.4); border-color: #e74c3c; }

        #lobby { position: absolute; inset: 0; background: #87CEEB; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
        .lobby-box { background: white; padding: 25px; border-radius: 20px; text-align: center; width: 90%; max-width: 380px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        .btn-p { padding: 8px 20px; font-size: 1.4rem; cursor: pointer; border: none; margin: 5px; font-family: 'Teko'; border-radius: 8px; width: 100%; }
        .speedo { position: absolute; top: 15px; right: 80px; font-size: 3rem; line-height: 0.8; text-align: right; color: #333; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <button class="invite-toggle-btn" id="inviteBtn" style="display:none;" onclick="toggleInviteSidebar()">â˜°</button>
    <div class="sidebar-menu" id="inviteSidebar">
        <div class="sidebar-header">
            <span style="font-size:1.4rem; color:#2ecc71;">INVITE FRIEND</span>
            <button class="close-btn" onclick="toggleInviteSidebar()">Ã—</button>
        </div>
        <div id="invite-list"><p style="color:#666;">Loading friends...</p></div>
    </div>

    <div id="lobby">
        <div class="lobby-box">
            <h1 style="font-size: 2.8rem; margin: 0;">CITY ONLINE</h1>
            <button class="btn-p" style="background:#2ecc71;color:white" id="createRoomBtn" onclick="createRoom()">CREATE WORLD</button>
            <div style="margin: 8px 0; color: #ccc; font-size: 1rem;">â€” OR â€”</div>
            <input type="text" id="roomInput" style="width:80%; padding:8px; font-size:1.4rem; text-align:center; margin-bottom:8px; border:1px solid #ddd; border-radius:5px;" placeholder="CODE">
            <button class="btn-p" style="background:#3498db;color:white" id="joinRoomBtn" onclick="joinRoom()">JOIN ROOM</button>
            <div id="status-msg" style="margin-top:8px; color:#e67e22; font-size: 1.1rem;"></div>
        </div>
    </div>

    <div id="ui-layer">
        <div id="chat-sidebar"><div id="chat-messages"></div><input type="text" id="chat-input" placeholder="Chat..."></div>
<canvas id="minimap" style="
position:absolute;
top:15px;
right:15px;
width:160px;
height:160px;
background:rgba(0,0,0,0.6);
border:2px solid #2ecc71;
border-radius:10px;
z-index:1100;
pointer-events:auto;
"></canvas>
        <div id="code-sidebar">
            <div class="side-btn" onclick="document.getElementById('code-sidebar').classList.toggle('open')">ðŸ”‘</div>
            <p id="display-code" style="font-size:1.8rem; margin:5px 0; font-weight:bold; color:#2ecc71;">----</p>
            <button onclick="copyCode()" style="width:100%; padding:4px; background:#2ecc71; color:white; border:none; border-radius:4px; font-family:'Teko'; cursor:pointer;">COPY</button>
        </div>
        <div class="speedo"><span id="speed-val">0</span><br><small style="font-size:0.9rem;">KM/H</small></div>
        <div class="controls-container">
            <div style="display:flex; gap:10px;"><div class="btn-touch" id="touch-left">â—€</div><div class="btn-touch" id="touch-right">â–¶</div></div>
            <div style="display:flex; gap:10px;"><div class="btn-touch pedal brake" id="touch-brake">BRK</div><div class="btn-touch pedal gas" id="touch-gas">GAS</div></div>
            <div id="bigMapContainer" style="
position:fixed;
top:0;
right:-100%;
width:100%;
max-width:400px;
height:100%;
background:rgba(10,10,10,0.95);
transition:0.4s;
z-index:1700;
display:flex;
flex-direction:column;
">
    <div style="display:flex;justify-content:flex-start;padding:10px;color:#2ecc71;font-size:1.5rem;gap:20px;">
    <span style="cursor:pointer;color:red;" onclick="toggleBigMap()">âœ–</span>
    <span>WORLD MAP</span>
</div>
    <canvas id="bigMap" style="flex:1;background:#111;"></canvas>
</div>
        </div>
    </div>

    <div id="game-container"></div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDCxIwIqiYc2FxT8qq1fbAsm2ym5DaFmsw",
            authDomain: "formywebfirebase.firebaseapp.com",
            databaseURL: "https://formywebfirebase-default-rtdb.firebaseio.com",
            projectId: "formywebfirebase",
            storageBucket: "formywebfirebase.firebasestorage.app",
            messagingSenderId: "451953941862",
            appId: "1:451953941862:web:b5f8394f99e17b232f3ca7"
        };
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        let scene, camera, renderer, car;
    // ===== INFINITE WORLD SYSTEM =====
const CHUNK_SIZE = 250;
const RENDER_DISTANCE = 2;
const activeChunks = new Map();
        let otherPlayers = {}; 
        let minimapCanvas = document.getElementById("minimap");
    let bigMapContainer = document.getElementById("bigMapContainer");
let bigMapCanvas = document.getElementById("bigMap");
let ctx = bigMapCanvas.getContext("2d");

minimapCanvas.addEventListener("click", toggleBigMap);
    // ðŸ“± Pinch Zoom Support
minimapCanvas.addEventListener("touchstart", function(e){
    if(e.touches.length === 2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        initialPinchDistance = Math.sqrt(dx*dx + dy*dy);
    }
}, { passive:false });

minimapCanvas.addEventListener("touchmove", function(e){
    if(e.touches.length === 2){
        e.preventDefault();

        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDistance = Math.sqrt(dx*dx + dy*dy);

        const diff = newDistance - initialPinchDistance;

        targetZoom += diff * 0.0005;

        targetZoom = Math.max(0.1, Math.min(0.5, targetZoom));
        

        initialPinchDistance = newDistance;
    }
}, { passive:false });
    // Zoom using mouse wheel (PC)
minimapCanvas.addEventListener("wheel", function(e){
    e.preventDefault();

    if(e.deltaY < 0){
        targetZoom += 0.05;
    } else {
        targetZoom -= 0.05;
    }

    targetZoom = Math.max(0.1, Math.min(0.5, targetZoom));
});

function toggleBigMap() {
    if (bigMapContainer.style.right === "0px") {
        bigMapContainer.style.right = "-100%";
    } else {
        bigMapContainer.style.right = "0";
        drawBigMap();
    }
}
let minimapCtx = minimapCanvas.getContext("2d");
    let minimapZoom = 0.2; 
let targetZoom = minimapZoom;
let bigMapZoom = 0.3; // Default zoom for Big Map
let bigMapTargetZoom = 0.3;
let initialPinchDistance = 0;

        let speed = 0, carDir = 0, roomId, myId;
        let keys = { up:0, down:0, left:0, right:0 };
        let buildings = [];
        const playerName = localStorage.getItem('playerName') || "Driver";
        let lastActivitySync = 0; // Throttling ke liye
        let isGameStarted = false;

        function init3D() {
            if (scene) return;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1500);
            camera.position.set(0, 7, -14); 
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2)); 
            document.getElementById('game-container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1.1));
            const sun = new THREE.DirectionalLight(0xffffff, 1.3);
            sun.position.set(50, 100, 50); scene.add(sun);

            
            car = createVehicle(0xe74c3c, playerName); scene.add(car);
            setupControls();
            animate();
            
            // Critical: Trigger resize after rendering starts
            window.dispatchEvent(new Event('resize'));
        }


        function createVehicle(color, name) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.8, 4.8), new THREE.MeshStandardMaterial({color: color, metalness: 0.6, roughness: 0.35}));
            body.position.y = 0.6; group.add(body);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.7, 2.4), new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.4}));
            cabin.position.set(0, 1.1, -0.4); group.add(cabin);
            const wheelGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.4, 16); wheelGeo.rotateZ(Math.PI / 2);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[1.2, 0.4, 1.7],[-1.2, 0.4, 1.7],[1.2, 0.4, -1.7],[-1.2, 0.4, -1.7]].forEach(p => { const w = new THREE.Mesh(wheelGeo, wheelMat); w.position.set(p[0], p[1], p[2]); group.add(w); });
            
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 256; canvas.height = 64; 
            ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(0,0,256,64); 
            ctx.font = 'bold 36px Teko'; ctx.fillStyle = '#222'; ctx.textAlign = 'center'; ctx.fillText(name, 128, 44);
            const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) })); label.position.y = 3.5; label.scale.set(4, 1, 1); group.add(label);
            return group;
        }
    // ===== CHUNK CREATION =====

function createChunk(cx, cz) {

    const chunkKey = cx + "," + cz;
    if (activeChunks.has(chunkKey)) return;

    const chunk = new THREE.Group();

    // Ground
    // ===== GROUND =====
const groundGeo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x6ccf3f }); // grass
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.set(cx * CHUNK_SIZE, 0, cz * CHUNK_SIZE);
chunk.add(ground);

// ===== ROAD (Cross Style) =====
const roadMat = new THREE.MeshStandardMaterial({ color: 0x444444 });

const roadWidth = 18;

// Horizontal road
const road1 = new THREE.Mesh(
    new THREE.PlaneGeometry(CHUNK_SIZE, roadWidth),
    roadMat
);
road1.rotation.x = -Math.PI / 2;
road1.position.set(cx * CHUNK_SIZE, 0.01, cz * CHUNK_SIZE);
chunk.add(road1);

// Vertical road
const road2 = new THREE.Mesh(
    new THREE.PlaneGeometry(roadWidth, CHUNK_SIZE),
    roadMat
);
road2.rotation.x = -Math.PI / 2;
road2.position.set(cx * CHUNK_SIZE, 0.01, cz * CHUNK_SIZE);
chunk.add(road2);
    // ===== RIVER (random chance) =====
/*if (Math.random() > 0.7) {
    const river = new THREE.Mesh(
        new THREE.PlaneGeometry(CHUNK_SIZE, 30),
        new THREE.MeshStandardMaterial({ color: 0x1e90ff })
    );
    river.rotation.x = -Math.PI / 2;
    river.position.set(cx * CHUNK_SIZE, 0.02, cz * CHUNK_SIZE);
    chunk.add(river);
}
    if (Math.random() > 0.7) {

    const bridgeGeo = new THREE.BoxGeometry(40, 2, 20);
    const bridgeMat = new THREE.MeshStandardMaterial({ color: 0x555555 });

    const bridge = new THREE.Mesh(bridgeGeo, bridgeMat);

    bridge.position.set(cx * CHUNK_SIZE, 8, cz * CHUNK_SIZE);

    bridge.userData.type = "bridge";   // tag correctly

    chunk.add(bridge);
}*/
    
    // ===== POLICE STATION (1 per chunk - Loop se bahar) =====
    const station = new THREE.Group();
    const base = new THREE.Mesh(new THREE.BoxGeometry(40, 12, 30), new THREE.MeshStandardMaterial({ color: 0xdddddd }));
    base.position.set(cx * CHUNK_SIZE + 60, 6, cz * CHUNK_SIZE - 60);
    station.add(base);
    const roof = new THREE.Mesh(new THREE.BoxGeometry(42, 2, 32), new THREE.MeshStandardMaterial({ color: 0x333333 }));
    roof.position.set(cx * CHUNK_SIZE + 60, 13, cz * CHUNK_SIZE - 60);
    station.add(roof);
    chunk.add(station);

    // Random buildings (Reduced & Road Avoidance)
    for (let i = 0; i < 4; i++) {
        const h = 15 + Math.random() * 35;
        const bX = (Math.random() - 0.5) * CHUNK_SIZE;
        const bZ = (Math.random() - 0.5) * CHUNK_SIZE;

        // Road avoidance: Don't spawn buildings near the center cross (roads)
        if (Math.abs(bX) < 25 || Math.abs(bZ) < 25) continue; 

        const building = new THREE.Mesh(
            new THREE.BoxGeometry(18, h, 18),
            new THREE.MeshStandardMaterial({ color: 0x777777 })
        );

        building.position.set(cx * CHUNK_SIZE + bX, h / 2, cz * CHUNK_SIZE + bZ);
        chunk.add(building);
        buildings.push(new THREE.Box3().setFromObject(building));
    }

    scene.add(chunk);
    activeChunks.set(chunkKey, chunk);
}

     /*  function getGroundHeight(x, z){
    return 0.4;
}*/


// ===== CHUNK UPDATE =====

function updateChunks() {

    const playerChunkX = Math.floor(car.position.x / CHUNK_SIZE);
    const playerChunkZ = Math.floor(car.position.z / CHUNK_SIZE);

    for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
        for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
            createChunk(playerChunkX + x, playerChunkZ + z);
        }
    }

}
    //Romoved Far Chunks Code here

        function handleMobileRotation() {
            if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().then(() => {
                        if (screen.orientation && screen.orientation.lock) screen.orientation.lock('landscape').catch(() => {});
                    });
                }
            }
        }

        function toggleInviteSidebar() { const s = document.getElementById('inviteSidebar'); s.classList.toggle('active'); if (s.classList.contains('active')) loadFriendsForInvite(); }
        function loadFriendsForInvite() { if (!playerName) return; db.ref('friends/' + playerName).once('value', snapshot => { const list = document.getElementById('invite-list'); list.innerHTML = ""; if (snapshot.exists()) { Object.keys(snapshot.val()).forEach(friendName => { const div = document.createElement('div'); div.style.cssText = "background:#222; padding:15px; margin-bottom:10px; border-radius:8px; display:flex; justify-content:space-between; align-items:center; border:1px solid #333;"; div.innerHTML = `<span style="color:white; font-size:1.1rem;">${friendName}</span><button onclick="sendInvite('${friendName}')" style="background:#2ecc71; color:black; border:none; padding:5px 10px; border-radius:4px; cursor:pointer; font-weight:bold; font-size:0.8rem; font-family:'Teko';">SEND CODE</button>`; list.appendChild(div); }); } else list.innerHTML = "<p style='color:#666;'>No friends found.</p>"; }); }
        function sendInvite(friendName) { if (!roomId) return alert("Create world first!"); const chatId = [playerName, friendName].sort().join('_'); db.ref('chats/' + chatId).push({ sender: playerName, text: "ðŸŽï¸ Join my Car Game 3D Multiplater World! Code: " + roomId, timestamp: Date.now() }); alert(`Invite sent to ${friendName}!`); toggleInviteSidebar(); }

        function createRoom() { 
            roomId = Math.floor(1000 + Math.random() * 9000).toString(); myId = 'p1'; 
            db.ref('car_world/' + roomId).set({ 
    status: 'waiting', 
    lastActivity: Date.now(), // 10 min timer start
    players: { p1: { x:0, z:0, r:0, n:playerName, color: 0xe74c3c } } 
}).then(() => { 
                document.getElementById('display-code').innerText = roomId; 
                document.getElementById('inviteBtn').style.display = 'block'; 
                document.getElementById('status-msg').innerHTML = `Room: <b>${roomId}</b>. Invite friends to start!`;
                toggleInviteSidebar(); // IMMEDIATE OPEN
                handleMobileRotation();
                // SYNC FIX: Using one persistent listener to detect players and then start
                const playerRef = db.ref('car_world/' + roomId + '/players');
                playerRef.on('value', snap => {
                    if(!isGameStarted && snap.numChildren() > 1) {
                        isGameStarted = true;
                        startGame();
                    } else if (isGameStarted) {
                        syncOtherPlayers(snap.val());
                    }
                });
            }); 
        }

        function joinRoom() { 
            const code = document.getElementById('roomInput').value; 
            db.ref('car_world/' + code).once('value').then(snap => { 
                if(!snap.exists()) return alert("No Room!"); 
                const players = snap.val().players || {};
                let slot = null;
                for(let i=1; i<=5; i++) if(!players['p'+i]) { slot = 'p'+i; break; }
                if(!slot) return alert("Room Full (Max 5)!");

                roomId = code; myId = slot;
                const pColor = [0x3498db, 0x2ecc71, 0xf1c40f, 0x9b59b6][Math.floor(Math.random()*4)];
                db.ref('car_world/' + roomId + '/players/' + myId).set({ x:Math.random()*10, z:Math.random()*10, r:0, n:playerName, color:pColor }).then(() => {
                    isGameStarted = true;
                    handleMobileRotation();
                    startGame();
                    db.ref('car_world/' + roomId + '/players').on('value', snap => syncOtherPlayers(snap.val()));
                });
            }); 
        }

        function startGame() {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('inviteBtn').style.display = 'block';
            init3D();
                        // Auto-Delete Check (Runs every 1 minute)
            setInterval(() => {
                db.ref('car_world/' + roomId).once('value', snap => {
                    if(!snap.exists()) return;
                    const data = snap.val();
                    const inactiveTime = Date.now() - data.lastActivity;

                    if(inactiveTime > 600000) { // 10 Minutes = 600,000 ms
                        alert("Room deleted due to 10 min inactivity!");
                        if(myId === 'p1') db.ref('car_world/' + roomId).remove(); // Only host deletes
                        location.reload();
                    }
                });
            }, 60000); 

            db.ref('car_world/' + roomId + '/chat').on('child_added', snap => { const m = snap.val(); const div = document.createElement('div'); div.innerHTML = `<b>${m.user}:</b> ${m.text}`; const box = document.getElementById('chat-messages'); box.appendChild(div); box.scrollTop = box.scrollHeight; });
        }
        function syncOtherPlayers(players) {
    if (!scene || !players) return;

    // 1. Remove players who left (Ghost Removal)
    for (let id in otherPlayers) {
        if (!players[id]) {
            scene.remove(otherPlayers[id]);
            delete otherPlayers[id];
        }
    }

    // 2. Add or Update players
    for (let id in players) {
        if (id === myId) continue;

        if (!otherPlayers[id]) {
            otherPlayers[id] = createVehicle(players[id].color || 0x3498db, players[id].n || "Player");
            otherPlayers[id].userData.username = players[id].n || "Player";
            scene.add(otherPlayers[id]);
        }

        if (!otherPlayers[id].userData.target) {
            otherPlayers[id].userData.target = new THREE.Vector3();
        }

        // Error Fix: getGroundHeight ki jagah fixed 0.4 use karein
        otherPlayers[id].userData.target.set(players[id].x, 0.4, players[id].z);
        otherPlayers[id].userData.targetRot = players[id].r;
    }
}

        function update() {
            let accel = keys.up ? 0.08 : (keys.down ? -0.05 : 0);
            speed = (speed + accel) * 0.95;
            if(Math.abs(speed) > 0.1) carDir += keys.left ? 0.05 : (keys.right ? -0.05 : 0);
            const nx = car.position.x + Math.sin(carDir) * speed, nz = car.position.z + Math.cos(carDir) * speed;
            const cBox = new THREE.Box3(new THREE.Vector3(nx-1.2,0,nz-2.5), new THREE.Vector3(nx+1.2,2,nz+2.5));
            let hit = false;
            for(let b of buildings) if(cBox.intersectsBox(b)) { hit = true; break; }
                        if(!hit) {
                car.position.set(nx, 0.4, nz);
                // Sync hamesha enable rakhein taaki movement smooth dikhe
                if (roomId && myId) {
                    db.ref('car_world/' + roomId + '/players/' + myId).update({ x: nx, z: nz, r: carDir });
                    
                    // Har 2 minute mein activity sync karein (Processor load kam karne ke liye)
                    if(Date.now() - lastActivitySync > 120000) {
                        db.ref('car_world/' + roomId).update({ lastActivity: Date.now() });
                        lastActivitySync = Date.now();
                    }
                }

            } 
            else { 
                speed = -speed * 0.4; 
            }

            car.rotation.y = carDir;
            camera.position.lerp(new THREE.Vector3(car.position.x - Math.sin(carDir)*14, 7, car.position.z - Math.cos(carDir)*14), 0.1);
            camera.lookAt(car.position);
            document.getElementById('speed-val').innerText = Math.floor(Math.abs(speed)*80);
        }

    function animate() {

    requestAnimationFrame(animate);

    if (car) {

    // Smooth zoom lerp
    minimapZoom += (targetZoom - minimapZoom) * 0.1;

    update();
    updateChunks();
    drawMinimap();
}

    // ðŸ”¥ Smooth Other Players
    for (let id in otherPlayers) {

        const p = otherPlayers[id];

        if (p.userData.target) {

            p.position.lerp(p.userData.target, 0.15);

            if (p.userData.targetRot !== undefined) {
                p.rotation.y += (p.userData.targetRot - p.rotation.y) * 0.15;
            }
        }
    }

    // Update big map live
    if (bigMapContainer.style.right === "0px") {
        drawBigMap();
    }

    renderer.render(scene, camera);
}
function drawMinimap() {
    if (!car) return;
    const size = 160;
    if (minimapCanvas.width !== size) { minimapCanvas.width = size; minimapCanvas.height = size; }
    
    const scale = minimapZoom;
    const centerX = size / 2;
    const centerY = size / 2;

    minimapCtx.clearRect(0, 0, size, size);
    minimapCtx.fillStyle = "rgba(0,0,0,0.6)";
    minimapCtx.fillRect(0,0,size,size);

    minimapCtx.save();
    minimapCtx.translate(centerX, centerY);
    // Rotate world OPPOSITE to car for player-centric view
    minimapCtx.rotate(-car.rotation.y); 

    // Environment (Roads & Buildings)
    minimapCtx.fillStyle = "#2ecc71";
    activeChunks.forEach((chunk) => {
        chunk.children.forEach(obj => {
            if (obj.geometry?.type === "BoxGeometry") {
                const dx = (obj.position.x - car.position.x) * scale;
                // FIX: Invert dy so the world moves opposite to the car
                const dy = -(obj.position.z - car.position.z) * scale; 
                if(Math.abs(dx) < 80 && Math.abs(dy) < 80) minimapCtx.fillRect(dx - 1, dy - 1, 2, 2);
            }
        });
    });

    // Other Players
    for (let id in otherPlayers) {
        const p = otherPlayers[id];
        const dx = (p.position.x - car.position.x) * scale;
        const dy = -(p.position.z - car.position.z) * scale;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 75) {
            minimapCtx.fillStyle = "red";
            minimapCtx.beginPath(); minimapCtx.arc(dx, dy, 4, 0, Math.PI * 2); minimapCtx.fill();
        }
    }

    // GPS Logic
    let nearest = null; let minDist = Infinity;
    for (let id in otherPlayers) {
        const d = car.position.distanceTo(otherPlayers[id].position);
        if (d < minDist) { minDist = d; nearest = otherPlayers[id]; }
    }
    if (nearest) {
        const tx = (nearest.position.x - car.position.x) * scale;
        const ty = -(nearest.position.z - car.position.z) * scale;
        minimapCtx.strokeStyle = "#00ffff";
        minimapCtx.setLineDash([5, 5]);
        minimapCtx.beginPath(); minimapCtx.moveTo(0, 0); minimapCtx.lineTo(tx, ty);
        minimapCtx.stroke(); minimapCtx.setLineDash([]);
    }
    minimapCtx.restore();

    // Player Arrow (Always UP)
    minimapCtx.fillStyle = "#00ff88";
    minimapCtx.beginPath();
    minimapCtx.moveTo(centerX, centerY - 10);
    minimapCtx.lineTo(centerX + 6, centerY + 8);
    minimapCtx.lineTo(centerX - 6, centerY + 8);
    minimapCtx.fill();
}



    
        function drawBigMap() {
    if (!car || bigMapContainer.style.right !== "0px") return;
    bigMapZoom += (bigMapTargetZoom - bigMapZoom) * 0.1;

    if (bigMapCanvas.width !== window.innerWidth) {
        bigMapCanvas.width = window.innerWidth;
        bigMapCanvas.height = window.innerHeight;
    }
    
    const ctx = bigMapCanvas.getContext("2d");
    const centerX = bigMapCanvas.width / 2;
    const centerY = bigMapCanvas.height / 2;
    const scale = bigMapZoom;

    ctx.fillStyle = "#111";
    ctx.fillRect(0, 0, bigMapCanvas.width, bigMapCanvas.height);

    ctx.save();
    // Center the map view on the player's position
    ctx.translate(centerX, centerY);

    // Draw Buildings (Map stays fixed, buildings move relative to player)
    ctx.fillStyle = "#34495e";
    activeChunks.forEach((chunk) => {
        chunk.children.forEach(obj => {
            if (obj.geometry?.type === "BoxGeometry") {
                const dx = (obj.position.x - car.position.x) * scale;
                const dy = -(obj.position.z - car.position.z) * scale;
                ctx.fillRect(dx - 5, dy - 5, 10, 10);
            }
        });
    });

    // Other Players
    for (let id in otherPlayers) {
        const p = otherPlayers[id];
        const dx = (p.position.x - car.position.x) * scale;
        const dy = (p.position.z - car.position.z) * scale;
        ctx.fillStyle = "red";
        ctx.beginPath(); ctx.arc(dx, dy, 7, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "white"; ctx.font = "14px Teko"; ctx.textAlign = "center";
        ctx.fillText(p.userData.username || "Player", dx, dy - 12);
    }

    // YOU Arrow (Rotating, but always in center)
    ctx.save();
    ctx.rotate(-car.rotation.y); // Use car's rotation for the arrow
    ctx.fillStyle = "lime";
    ctx.beginPath();
    ctx.moveTo(0, -18); ctx.lineTo(10, 14); ctx.lineTo(-10, 14);
    ctx.fill();
    ctx.restore();

    ctx.restore();
}
    
       
        function sendChat() { 
    const i = document.getElementById('chat-input'); 
    if(!i.value) return; 
    db.ref('car_world/' + roomId + '/chat').push({ user: playerName, text: i.value }); 
    // Activity update on chat
    db.ref('car_world/' + roomId).update({ lastActivity: Date.now() });
    i.value = ""; 
}

        function copyCode() { navigator.clipboard.writeText(roomId); alert("Code: " + roomId); }
        
        window.addEventListener('resize', () => {
            if(!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function setupControls() {
            const b = (id, k) => { const el = document.getElementById(id); el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[k] = 1; }, {passive: false}); el.addEventListener('touchend', (e) => { e.preventDefault(); keys[k] = 0; }, {passive: false}); };
            b('touch-gas', 'up'); b('touch-brake', 'down'); b('touch-left', 'left'); b('touch-right', 'right');
            window.onkeydown = e => { if(e.key === 'Enter') sendChat(); if(e.key==='w'||e.key==='ArrowUp') keys.up=1; if(e.key==='s'||e.key==='ArrowDown') keys.down=1; if(e.key==='a'||e.key==='ArrowLeft') keys.left=1; if(e.key==='d'||e.key==='ArrowRight') keys.right=1; };
            window.onkeyup = e => { if(e.key==='w'||e.key==='ArrowUp') keys.up=0; if(e.key==='s'||e.key==='ArrowDown') keys.down=0; if(e.key==='a'||e.key==='ArrowLeft') keys.left=0; if(e.key==='d'||e.key==='ArrowRight') keys.right=0; };
        }
    </script>
</body>
</html>
