<!DOCTYPE html>
<html lang="en">
<head>
    <script>
        // SECURITY CHECK
        if (localStorage.getItem('isLoggedIn') !== 'true') {
            window.location.href = '../LoginPlease/login.html';
        }
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Car City Drift - Fixed</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@500;700&display=swap');
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Teko', sans-serif; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        .hud-top { display: flex; justify-content: space-between; padding: 20px; text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5); }
        .speed-val { font-size: 4rem; color: #fff; line-height: 0.8; }
        .nitro-container { width: 250px; height: 15px; background: rgba(0, 0, 0, 0.5); border: 2px solid #fff; transform: skewX(-20deg); margin-top: 10px; overflow: hidden; }
        .nitro-fill { height: 100%; background: linear-gradient(90deg, #ff9800, #ff5722); width: 0%; transition: width 0.1s; }
        .mobile-controls { display: flex; justify-content: space-between; padding: 20px 40px; pointer-events: auto; padding-bottom: 40px; }
        .btn-round { width: 70px; height: 70px; border-radius: 50%; background: rgba(0, 0, 0, 0.3); border: 2px solid #fff; color: white; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; margin: 0 5px; }
        .pedal { width: 60px; height: 100px; border-radius: 10px; background: rgba(0,0,0,0.3); border: 2px solid #fff; color: white; display: flex; align-items: center; justify-content: center; margin-left: 10px; }
        #main-menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; backdrop-filter: blur(5px); }
        h1 { font-size: 6rem; color: white; font-style: italic; margin: 0; }
        .start-btn { padding: 15px 50px; font-size: 2rem; background: #e74c3c; border: 2px solid #fff; color: white; cursor: pointer; font-family: 'Teko'; }
        .back-link { position: absolute; top: 20px; left: 20px; color: #fff; text-decoration: none; border: 1px solid #fff; padding: 5px 15px; pointer-events: auto; background: rgba(0,0,0,0.3); z-index: 110; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="game-container"></div>
    <div id="ui-layer">
        <a href="../index.html" class="back-link">← Menu</a>
        <div class="hud-top">
            <div style="flex-grow:1"></div>
            <div style="text-align:right">
                <div class="speed-val" id="speed-display">0</div>
                <div style="color:yellow">KM/H</div>
                <div class="nitro-container"><div class="nitro-fill" id="nitro-bar"></div></div>
            </div>
        </div>
        <div class="mobile-controls">
            <div style="display:flex;"><div class="btn-round" id="btn-left">◀</div><div class="btn-round" id="btn-right">▶</div></div>
            <div style="display:flex;"><div class="btn-round" id="btn-nitro" style="background:orange">N</div><div class="pedal" id="btn-brake" style="background:red">BRK</div><div class="pedal" id="btn-gas" style="background:green">GAS</div></div>
        </div>
    </div>
    <div id="main-menu">
        <h1>REAL CITY</h1>
        <button class="start-btn" onclick="startGame()">DRIVE</button>
    </div>

    <script>
        let scene, camera, renderer, car, carModel;
        let wheels = [], buildings = [], particles = [];
        let speed = 0, maxSpeed = 3.0, carDir = 0, nitroAmt = 100, isNitro = false;
        let keys = { up: false, down: false, left: false, right: false, nitro: false, brake: false };
        let exhaustGeo, exhaustMat; // Will be initialized in init()

        function init() {
            // Initialize Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 600);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1500);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Assets (Now safe to create after THREE is loaded)
            exhaustGeo = new THREE.PlaneGeometry(0.4, 0.4);
            exhaustMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });

            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const sun = new THREE.DirectionalLight(0xffffff, 1.0);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            scene.add(sun);

            createCity();
            createCar();
            setupControls();
            animate();
        }

        function createCity() {
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshStandardMaterial({ color: 0x4CAF50 }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const blockSize = 80, roadWidth = 22, citySize = 8;
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const winMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            for (let x = -citySize/2; x < citySize/2; x++) {
                for (let z = -citySize/2; z < citySize/2; z++) {
                    const cx = x * blockSize, cz = z * blockSize;
                    const r1 = new THREE.Mesh(new THREE.PlaneGeometry(blockSize+roadWidth, roadWidth), roadMat);
                    r1.rotation.x = -Math.PI/2; r1.position.set(cx, 0.05, cz); scene.add(r1);
                    
                    [[cx-25, cz-25], [cx+25, cz-25], [cx-25, cz+25], [cx+25, cz+25]].forEach(pos => {
                        const h = 30 + Math.random() * 40, w = 20;
                        const bGroup = new THREE.Group();
                        const bMesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
                        bMesh.position.y = h/2; bMesh.castShadow = true; bGroup.add(bMesh);

                        // Windows
                        for(let f=5; f<h-5; f+=10) {
                            const win = new THREE.Mesh(new THREE.BoxGeometry(w+0.2, 2, w+0.2), winMat);
                            win.position.y = f; bGroup.add(win);
                        }
                        bGroup.position.set(pos[0], 0, pos[1]);
                        scene.add(bGroup);
                        buildings.push(new THREE.Box3().setFromObject(bMesh));
                    });
                }
            }
        }

        function createCar() {
            car = new THREE.Group(); carModel = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.7, 4.5), new THREE.MeshStandardMaterial({ color: 0xcc0000, metalness: 0.5 }));
            body.position.y = 0.7; body.castShadow = true; carModel.add(body);
            
            const wGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16); wGeo.rotateZ(Math.PI/2);
            const wMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[1.1, -1.5], [-1.1, -1.5], [1.1, 1.5], [-1.1, 1.5]].forEach((p, i) => {
                const w = new THREE.Mesh(wGeo, wMat); w.position.set(p[0], 0.5, p[1]);
                carModel.add(w); if(i<2) wheels.push(w);
            });
            car.add(carModel); scene.add(car);
        }

        function createExhaust(pos) {
            if (!exhaustMat) return;
            const p = new THREE.Mesh(exhaustGeo, exhaustMat.clone());
            p.position.copy(pos); p.rotation.copy(car.rotation);
            p.userData = { life: 15 }; scene.add(p); particles.push(p);
        }

        function update() {
            let accel = keys.up ? 0.06 : (keys.down ? -0.04 : 0);
            if (keys.nitro && nitroAmt > 0) { accel *= 2.2; maxSpeed = 5.5; nitroAmt -= 0.8; isNitro = true; }
            else { maxSpeed = 3.0; nitroAmt = Math.min(100, nitroAmt+0.2); isNitro = false; }

            speed = (speed + accel) * 0.98;
            speed = Math.max(-1, Math.min(maxSpeed, speed));

            if (Math.abs(speed) > 0.1) {
                const turn = keys.left ? 0.04 : (keys.right ? -0.04 : 0);
                carDir += turn;
                wheels.forEach(w => w.rotation.y = turn * 10);
            }

            const nextX = car.position.x + Math.sin(carDir) * speed;
            const nextZ = car.position.z + Math.cos(carDir) * speed;
            const carBox = new THREE.Box3(new THREE.Vector3(nextX-1, 0, nextZ-2), new THREE.Vector3(nextX+1, 2, nextZ+2));

            let collision = false;
            for (let b of buildings) {
                if (Math.abs(b.min.x - nextX) < 30 && carBox.intersectsBox(b)) { collision = true; break; }
            }

            if (!collision) { car.position.set(nextX, 0, nextZ); } else { speed = -speed * 0.5; }
            car.rotation.y = carDir;

            camera.position.lerp(new THREE.Vector3(car.position.x - Math.sin(carDir)*12, 6+speed, car.position.z - Math.cos(carDir)*12), 0.1);
            camera.lookAt(car.position);

            if (isNitro && Math.abs(speed) > 1 && Math.random() > 0.5) {
                const pPos = new THREE.Vector3(0, 0.5, -2.2).applyMatrix4(car.matrixWorld);
                createExhaust(pPos);
            }
            particles.forEach((p, i) => { 
                p.userData.life--; p.material.opacity *= 0.9; 
                if(p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
            });

            document.getElementById('speed-display').innerText = Math.floor(Math.abs(speed) * 85);
            document.getElementById('nitro-bar').style.width = nitroAmt + "%";
        }

        function animate() { requestAnimationFrame(animate); update(); renderer.render(scene, camera); }
        
        function startGame() { 
            document.getElementById('main-menu').style.display = 'none'; 
            init(); 
        }

        function onResize() { 
            if (!camera) return;
            camera.aspect = window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        }

        function setupControls() {
            const handle = (e, val) => {
                if (e.key === 'ArrowUp' || e.key === 'w') keys.up = val;
                if (e.key === 'ArrowDown' || e.key === 's') keys.down = val;
                if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = val;
                if (e.key === 'ArrowRight' || e.key === 'd') keys.right = val;
                if (e.key === 'Shift') keys.nitro = val;
            };
            document.addEventListener('keydown', e => handle(e, true));
            document.addEventListener('keyup', e => handle(e, false));
            const bind = (id, k) => {
                const el = document.getElementById(id);
                el.onmousedown = el.ontouchstart = (e) => { e.preventDefault(); keys[k] = true; };
                el.onmouseup = el.ontouchend = (e) => { e.preventDefault(); keys[k] = false; };
            };
            bind('btn-gas', 'up'); bind('btn-brake', 'down'); bind('btn-left', 'left'); bind('btn-right', 'right'); bind('btn-nitro', 'nitro');
            window.addEventListener('resize', onResize);
        }
    </script>
</body>
</html>
